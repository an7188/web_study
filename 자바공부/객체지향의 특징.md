# 객체지향 언어의 특징

## 추상화

### Class 와 Object

### 프로그램의 클래스와 객체

- Class(클래스)
  - 객체를 정의해 놓은 것 즉 객체의 설계도, 틀
  - 클래스는 직접 사용할 수 없고 직접 사용되는 객체를 만들기 위한 틀을 제공
  - 멤버 변수와 메서드를 가질 수 있다.
- instance, object (객체)
  - 클래스를 데이터 타입으로 메모리에 생성되는 것





## 상속

- 기존 클래스의 자산(멤버)을 자식 클래스에서 재사용하기 위한 것
- 기존 클래스의 멤버를 물려 받기 때문에 코드의 절감

### 1. Object클래스

→ 모든 클래스의 조상 클래스

- 별도의 extends 선언이 없는 클래스들은 extends Object가 생략!!
- 따라서 모든 클래스는 오브젝트 클래스에 정의된 메서드가 있음

### 2. 매서드 오버라이딩(overriding)

→ 조상 클래스에 정의된 메서드를 자식 클래스에서 적합하게 수정하는 것

메서드 오버로드와 잘 구별하기!

**(1) 오버라이딩의 조건**

- 메서드 이름이 같아야한다.
- 매개 변수의 개수, 타입, 순서가 같아야한다.
- 리턴 타입이 같아야 한다.
- 접근 제한자는 부모 보다 범위가 넓거나 같아야 한다.
- 조상보다 더 큰 예외를 던질 수 없다.

### 3.  단일 상속

- 다중 상속의 경우 여러 클래스의 기능을 물려 받을 수 있으나 관계가 매우 복잡해짐
- 자바는 단일 상속만 지원~
  - 대신 interface와 포함 관계로 단점 극복!!

### 4. 포함 관계

- 2개 이상의 클래스에서 특성을 가져올 때 하나는 상송, 하나는 멤버 변수로 처리

### 5. super 키워드

- this통해 멤버에 접근했듯이 super를 통해 조상 클래스 멤버 접근
- super.을 이용해 조상의 메서드 호출로 조상의 코드 재사용
- this()가 해당 클래스의 다른 생성자를 호출하듯 super()는 조상 클래스의 생성자 호출
- super()는 자식 클래스 생성자의 맨 첫 줄에서만 호출 가능
- 명시적으로 써주지 않는다면 컴파일러가 super() 자동으로 삽입!!!





## 다형성(polymorphism)

- 하나의 객체가 많은 형(타입)을 가질 수 있는 성질

- 상속 관계에 있을 때 조상 클래스의 타입으로 자식 클래스 객체를 래퍼런스 할 수 있음

  ex) 씨→  열매 →  사과 → 과일 (이렇게 상속을 받았다면)

  - 사과 타입으로 열매을 참조 가능!
  - 과일 타입으로 과일 참조 가능!
  - but! 씨 타입으로 열매 참조는 불가능~

- 다른 타입으로 바꿔 객체를 생성한다면 하나의 객체로 여러 클래스를 관리 할 수 있다~

- 형변환

  - 자손 타입의 객체를 조상 타입으로 참조 → 묵시적 케스팅 (형변환 생략 가능)
  - 조상의 타입을 자손 타입을 참조 → 명시적 케스팅 (형변환 생략 불가)

- 상속 관계에서 객체의 메서드가 중복될 때 (메서드가 오버라이드 되었을때)

  - 무조건 자식 클래스의 메서드가 호출된다~





## 데이터 은닉과 보호

### 제한자(modifier)

- 클래스, 변수, 메서드 선언부에 함께 사용되어 부가적인 의미 부여
- 하나의 대상에 여러 제한자를 조합 가능하나 접근 제한자는 하나만 사용 가능

✔ 접근 제한자 : public, protected, (default = package) , private

✔ 그 외 제한자 : static , final, abstract, synchronized

1. final

→ 마지막, 더 이상 바뀔 수 없음

- final class → 더 이상 확장 할 수 없음 (오버라이드 금지)
- final method → 더 이상 재 정의 할 수 없음 (오버라이딩 금지)
- final variable → 더 이상 값을 바꿀 수 없음 (상수화)
- 

### singleton 디자인 패턴

- 외부에서 생성자에 접근 금지 → 생성자의 접근 제한자를 private으로 설정

```java
public class Teacher{
		// 자신의 클래스에서만 만들며
		private Teacher t = new Reacher();
		//외부에서 생성 불가
		private Teacher(){

		}
		// getTeacher 메소드로만 통해서 접근가능
		public Teacher getTeacher(){
				return t;
		}		

//Teacher t1 =Teacher.getTeacher -> 이렇게 접근
}
```

- 여러 개의 객체가 필요 없는 경우
  - 객체를 구별할 필요가 없음 = 수정 가능한 멤버 변수가 없고 기능만 있는 경우
  - 이런 객체를 stateless 한 객체라고 한다.
- 객체를 계속 생성 / 삭제 하는데 많은 비용이 들어서 재사용이 유리한 경우